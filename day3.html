<!DOCTYPE html>
<html>
<head>
  <title>Rock the Web with NodeJS - jour 3</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="components/normalize-css/normalize.css" />
  <link rel="stylesheet" href="components/font-awesome/css/font-awesome.min.css" />
  <link rel="stylesheet" href="components/highlightjs/styles/tomorrow.css" />
  <link rel="stylesheet" href="components/ruban/css/ruban.min.css" />
  <link rel="stylesheet" href="components/ruban/css/ruban-print.min.css" media="print" />
  <link rel="stylesheet" href="css/day3.min.css" />
</head>

<body>
  <div class="time"></div>

  <section class="title main" data-timing="10">
    <img class="bg" src="images/rock-blur.jpg">
    <h1>Rock The Web with Node.js</h1>
  </section>

  <section id="npm" class="title">
    <div class="bg">
      <img src="images/npm.png">
    </div>
    <h1>The Node Package Manager</h1>
  </section>

  <section data-timing="5">
    <h1>Packager son projet</h1>
    <ul class="steps">
      <li>Dans l'écosystème NodeJS* on utilise une foule de librairies spécialisées</li>
      <li>Une librairie répond généralement à une problématique simple</li>
      <li>Votre application utilisera des librairies, et en sera peut-être une elle-même</li>
      <li><code>package = modules + dépendances + tests</code></li>
      <li>NPM vous aide à packager et distribuer votre projet</li>
    </ul>
    <details open>
      <summary/>
      <p>(*) dans l'ecosystème JavaScript en général</p>
      <p><strong>moment</strong> = manipulation de dates, <strong>underscore</strong>/<strong>lodash</strong> = manipulation des tableaux/collections, <strong>mongodb-native</strong> = driver MongoDB, <strong>js-yaml</strong> = parser YAML...</p>
      <p>Dans une société, il est courant de réaliser des librairies pour des briques logicielles internes (connexion au DAS...), ou pour mutualiser un savoir-faire métier</p>
      <p>Même si votre application n'est pas destinée à être réutilisée, la packager est une nécessité</p>
      <p>NPM apporte des conventions (package.json) et des outils pour la distribution (registry central + client de packaging)</p>
    </details>
  </section>

  <section data-timing="5">
    <h1>Exemples de structure</h1>
    <ul class="steps">
      <li>Librairie ou executable en ligne de commandes : <pre><code class="python">lib/            # votre code (aussi libs)
node_modules/   # les dépendances gérées par NPM
test/           # le code de vos tests
.npmignore      # les exclusions du package
README.md
package-lock.json # à partir de NPM 5 (node 8)
package.json
</code></pre></li>
      <li>Application Web serveur & client : <pre><code class="python">app/            # code serveur uniquement
  tests/
assets/         # Les assets coté serveur
config/         # les fichiers de configuration (aussi conf)
node_modules/   # les dépendances serveur gérées par NPM
public/         # code client
  dist/         # le client minifié
  test/
  vendor/       # dépendances client, gérées par bower/webpack... (aussi libs)
  package-lock.json # à partir de NPM 5 (node 8)
  package.json
</code></pre></li>
    </ul>
    <details open>
      <summary/>
      <p>2 points communs: <code>package.json</code> et <code>node_modules</code> sont toujours à la racine</p>
      <p>Il est courant de mettre le code du client et du serveur dans le même package : en NodeJS, le serveur static et le même que le serveur d'API/pages web dynamiques</p>
      <p>NPM gère les dépendances coté serveur majoritairement, mais diversifie de plus en plus son écosystème, malgré tout d'autres outils permettent de gérer les dépendances coté client (<a href="http://bower.io/" target="_blank">bower</a>, <a href="http://browserify.org/" target="_blank">browserify</a>, <a href="http://webpack.github.io/" target="_blank">webpack</a> et d'autres encore...)</p>
      <p>Le versionning, avec git par exemple, sera aussi à la racine</p>
      <p><strong>Attention !</strong> En l'absence d'un <code>.npmignore</code>, NPM utilisera le <code>.gitignore</code> éventuel</p>
      <p>Ce ne sont que des exemples : il n'y a pas de dogme, et on trouve ne nombreuses variantes, souvient liée aux outils de build ou au serveur</p>
    </details>
  </section>

  <section data-timing="5">
    <h1>Le fichier <code>package.json</code></h1>
    <ul class="steps">
      <li>Descripteur du projet<pre><code class="json">{
  "name": "nom-du-projet",
  "version": "0.3.1",
  "description": "Elle sera publiée",
  "author": "You <you@yopmail.com>",
  "license": "MIT",
  "repository": "https://github.com/you/nom-du-projet.git",
  "dependencies": {
    "lodash": "~2.4.1"
  },
  "main": "./lib/entry_point.js",
  "bin": {
    "start-project": "./bin/start"
  },
  "scripts": {
    "test": "mocha test"
  },
  "engines": {"node": ">=0.10.3"}
}
</code></pre></li>
    </ul>
    <details open>
      <summary/>
      <p><code>name</code> et <code>version</code> sont les deux seuls champs obligatoires les plus importants de votre descripteur</p>
      <p><code>name</code> doit être en minuscule, sans lettres exotiques, raisonnablement court et descriptif. Il sera dans des <code>require()</code> et fera partie d'une url !</p>
      <p><code>version</code> doit respecter le format <a href="http://semver.org/" target="_blank">semver</a></p>
      <p><code>description</code>, <code>keywords</code> permettront aux développeurs qui cherchent des librairies sur le registry NPM de trouver la vôtre</p>
      <p><code>author</code>, <code>constributors</code>, <code>license</code> relètent l'état de la communauté autour de votre projet</p>
      <p><code>repository</code>, <code>homepage</code>, <code>bugs</code> sont des url affichées sur le site du registry NPM pour simplifier l'accès à votre code</p>
      <p><code>dependencies</code>, <code>devDependencies</code>, <code>peerDependencies</code>, <code>bundledDependencies</code> et <code>optionalDependencies</code> décrivent les dépendances de votre projet. Nous y reviendrons juste après</p>
      <p>Dans le cas d'une librairie, <code>main</code> indique quel est le module qui sera chargé lors d'un <code>require('nom-du-projet');</code></p>
      <p><code>bin</code> déclare les éventuel exécutables, indispensable pour un projet de type CLI</p>
      <p><code>scripts</code> permet de customiser les phases de packaging et d'ajouter ses propres phases</p>
      <p><code>engines</code>, <code>engineStrict</code>, <code>cpu</code>, <code>os</code> permettent de déclarer des restrictions de portabilité</p>
    </details>
  </section>

  <section data-timing="5">
    <h1>Le fichier <code>package-lock.json</code></h1>
    <ul class="steps">
      <li>Créé et mis à jour par NPM à partir de la version 5 (nodeJS 8)</li>
      <li>Contient l'arbre des dépendences</li>
      <li>Doit être committé</li>
      <li>Permet de reproduire un <code>npm install</code> de manière sûre</li>
      <li>Permet également d'accélérer le <code>npm install</code></li>
    </ul>
    <details open>
      <summary/>
      <p>ça évite les cas où un projet ne fonctionne plus car une librairie a introduit (par erreur) un breaking change</p>
    </details>
  </section>

  <section data-timing="5">
    <h1>Déclarer ses dépendances</h1>
    <ul class="steps">
      <li>Dépendance = nom du package + contrainte de version</li>
      <li><code>^x.y.z</code> : le premier chiffre différent de 0 est fixé (les autres chiffres au minimum)
        <ul>
          <li>ex: <code>^1.2.3</code> équivaut à <code>&gt;= 1.2.3 &lt;2.0.0</code></li>
          <li>ex: <code>^0.1.2</code> équivaut à <code>&gt;= 0.1.2 &lt;0.2.0</code></li>
          <li>ex: <code>^0.0.1</code> équivaut à <code>0.0.1</code></li>
        </ul>
      <li><code>~x.y.z</code> : la version x.y la plus haute (z au minimum)
        <ul>
          <li>ex: <code>~1.2.3</code> équivaut à <code>&gt;= 1.2.3 &lt;1.3.0</code></li>
          <li>ex: <code>~0.1.2</code> équivaut à <code>&gt;= 0.1.2 &lt;0.2.0</code></li>
        </ul>
      </li>
    </ul>
    <details open>
      <summary/>
      <p>Il existe des des opérateurs <code><</code>, <code><=</code>, <code>></code>, <code>>=</code>, NPM prendra la version la plus haute disponible</p>
      <p>Il y a aussi des jokers <code>*</code>, <code>x</code></p>
      <p>Enfin l'opérateur chapeau <code>~x.y.z</code> : la version x.y la plus haute (z au minimum)</p>
      <p><a href="https://nodesource.com/blog/semver-tilde-and-caret" target="_blank">Un article détaillé</a> sur le comportement de <code>~</code> et <code>^</code></p>
    </details>
  </section>

  <section data-timing="5">
    <h1>Déclarer ses dépendances</h1>
    <ul class="steps">
      <li><code>x.y.z</code> : exactement la version</li>
      <li>l'<strong>url</strong> d'un dépôt git : <code>git://github.com/user/project.git#commit</code></li>
      <li>l'<strong>url</strong> d'un tarball : <code>http://bitbucket.org/user/repo?format=tar.gz</code></li>
      <li class="convention">Pour rester portable, n'utilisez que ces syntaxes</li>
      <li class="guideline">Utiliser la commande <code>npm install ma-lib</code> qui mettra à jour les fichiers <code>package.json</code> et <code>package-lock.json</code></code></li>
    </ul>
  </section>

  <section data-timing="5">
    <h1>Publier sur le registry</h1>
    <ul class="steps">
      <li>NPM est un dépôt en ligne, avec un <a href="https://www.npmjs.com/" target="_blank">site de recherche</a></li>
      <li>Peut héberger vos propres packages (<strong>publish</strong>)</li>
      <li>Le <a href="https://www.npmjs.com/package/lodash" target="_blank">site affiche</a> le <strong>README.md</strong>, les mot-clés, les stats de téléchargement, les dépendances...</li>
      <li>Le dépôt contient toutes les versions publiés</li>
      <li>Il est utilisé par défaut par le CLI (<strong>install</strong>, <strong>publish</strong>)</li>
    </ul>
    <details open>
      <summary/>
      <p><a href="https://docs.npmjs.com/getting-started/what-is-npm" target="_blank">Cette vidéo</a> explique bien le fonctionnement</p>
      <p>Contrairement à l'écosystème Java, il n'y a qu'un seul dépôt central pour les packages NodeJS. Il existe des mirroirs qui sont en train de disparaitres avec la fiabilisation du dépôt central, ne les utilisez pas.</p>
      <p>Il est possible de créer des dépôts privés (<a href="https://docs.npmjs.com/enterprise/requirements" target="_blank">NPM Entreprise</a>), ou de payer un espace privé sur npmjs.com (<a href="https://www.npmjs.com/private-npm" target="_blank">a venir</a>)</p>
      <p><strong>Attention !</strong> vous ne devez (pouvez) pas republiez une version déjà existante !</p>
      <p>D'autres clients (bower...) utilisent aussi ce dépôt</p>
    </details>
  </section>

  <section data-timing="5">
    <h1>Le client NPM</h1>
    <ul class="steps">
      <li>NPM vient avec une interface en ligne de commande</li>
      <li>Il lit le descripteur lors de certaines commandes :<ul>
        <li><code>npm install</code> : récupération & compilation des dépendances, création des exécutables</li>
        <li><code>npm test</code> : lance l'exécution des tests présents</li>
        <li><code>npm start/restart/stop</code> : lance et arrête le projet</li>
        <li><code>npm publish</code> : publie le projet sur le registry central</li>
      </ul></li>
      <li><strong>NPM !== <i>build-system</i></strong>, NPM === gestion de dépendances</li>
    </ul>
    <details open>
      <summary/>
      <p>La récupération d'une dépendance revient à télécharger le code, et réaliser un <code>npm install</code> dans le dossier de manière transitive</p>
      <p>Les commandes <code>npm test/start/restart/stop</code> exécutent les scripts <strong>preX</strong>, <strong>X</strong> et <strong>postX</strong> lorsqu'ils existent</p>
      <p>La commande <code>npm run-script X</code> exécute les scripts <strong>preX</strong>, <strong>X</strong> et <strong>postX</strong> de la même manière</p>
      <p>Certaines phases (<strong>postinstall</strong>, <strong>prepublish</strong>...) peuvent être customisées avec les <code>scripts</code> du descripteur</p>
      <p>Il n'y a pas cycle de vie ni de phases ordonnancées</p>
      <p>Les scripts sont dépendants de la plateforme</p>
      <p>Il peut y avoir une <a href="https://github.com/TooTallNate/node-gyp" target="_blank">compilation de code C/C++</a> lors de l'installation d'une dépendance</p>
      <p>A la fin de l'installation du package si celui-ci contient des executables (<code>package.json/bin</code>), ils sont enregistrés en global au niveau système si npm est lancé avec l'option -g</p>
      <p>NPM n'est pas un <i>build-system</i> : il ne permet pas de déclarer et d'ordonnancer des tâches de mettre en oeuvre des configuration par environnement, et d'être un outil de compilation/packaging portable. Il propose des mécanismes minimalistes pour le packaging, dans l'unique optique de la publication</p>
    </details>
  </section>

  <section id="mocha" class="title">
    <img class="bg" src="images/mocha.jpg">
    <h1>Behaviour Driven Development !</h1>
  </section>

  <section>
    <h1><a href="http://mochajs.org">Mocha</a> : le test runner</h1>
    <ul class="steps">
      <li>Dans un fichier test/my-lib.js<pre><code class="javascript">const assert = require('assert');
// describe est une fonction qui définit un "groupe" de tests
describe('Array#indexOf', () => {
  // it est une fonction qui définit un test (pas d'inclusion)
  it('should return -1 when the value is not present', () => {
    // contenu du test : si le test lance une exception, il échoue
    assert.equal(-1, [1,2,3].indexOf(5));
    assert.equal(-1, [1,2,3].indexOf(0));
  })

  it('should return index when the value is present', () => {
    assert.equal(2, [1,2,3].indexOf(3));
    assert.equal(0, [1,2,3].indexOf(1));
    // s'il arrive à la fin, il réussit
  })
})</code></pre></li>
      <li>En ligne de commande : <code>mocha test</code></li>
    </ul>
    <details open>
      <summary/>
      <p><code>describe()</code> et <code>it()</code> sont des fonctions globales, définies par <strong>mocha</strong>. Il en existe d'autre que nous verrons plus loins</p>
      <p><strong>Mocha</strong> propose l'interface BDD (par défaut), celle de l'exemple. Il propose aussi l'interface TDD, où <code>describe()</code> = <code>suite()</code> et <code>it()</code> = <code>test()</code></p>
      <p>Nous verrons plus loin en quoi l'interface TDD est moins intéressante</p>
      <p>Mocha fonctionne en 2 phases : la détection des tests : <ol>
        <li>il exécute tous les contenus de <code>describe</code> pour avoir la liste des <code>it()</code></li>
        <li>il exécute les <code>it()</code> un à un</li></ol></p>
      <p><code>assert</code> est un module NodeJS que nous n'utiliseront pas à cause de ses faibles capacités de reporting</p>
      <p><strong>Mocha</strong> est totallement décoréllé de NodeJS, et s'utilise très bien dans un navigateur</p>
      <p>Il existe différents reporters, essayer le reporter <a href="https://www.youtube.com/watch?v=QH2-TGUlwu4">nyan !</a></p>
    </details>
  </section>



  <section data-timing="5">
    <h1><a href="http://chaijs.com/" target="_blank">Chai</a> : les assertions</h1>
    <ul class="steps">
      <li class="no-bullet"><pre><code class="javascript">
// notez l'inclusion de chai
const expect = require('chai').expect;

describe('Array#indexOf', () => {
  it('should return -1 when the value is not present', (done) => {
    const array = [1, 2, 3];

    // permet de faire la même chose...
    expect(array.indexOf(5)).to.equal(-1);

    //...et des assertions bien plus expressives !
    expect(array).to.be.an.instanceof(Array).and.to.have.a.lengthOf(3);
    expect(array).to.include(2);
    expect(array).not.to.contain(4);
    done();
  });
});</code></pre></li>
      <li class="guideline">3 styles possibles <strong>expect</strong> est le meilleur compromis</li>
    </ul>
    <details open>
      <summary/>
      <p>La combinaison <strong>Mocha mode BDD</strong> + <strong>Chai mode expect</strong> donne suffisamment de lisibilité au code pour qu'il reflète des spécifications fonctionnelles ! Vous n'aurez plus besoin de documenter vos assertions et vos cas de tests, car ils doivent être suffisamment parlants</p>
      <p>Tout comme <strong>Mocha</strong>, <strong>Chai</strong> est totalement décorrélé de NodeJS, et s'utilise très bien dans un navigateur, il a malgré tout une API inconsistante</p>
      <p>Le style d'assertion <strong>should</strong> est mal supporté sur IE car il instrumente les objets testés</p>
      <p>Le style d'assertion <strong>assert</strong> est vraiment trop has-been :)</p>
      <p>Une assertion <strong>Chai</strong> est une chaine de mots dont certains sont sans effet (<strong>to, be, been, is, that, and, has, have, with, at, of, same</strong>), et d'autres déclenchent une validation (<strong>instanceof(), lengthOf(), include()...</strong>), qui si elle échoue lèvera une exception</p>
      <p>Le message d'exception reprend les mots précédents pour être suffisamment parlant : <code>expected [ 1, 2, 3 ] to have a length of 4 but got 3</code></p>
    </details>
  </section>

  <section data-timing="10">
    <h1>Les assertions disponibles</h1>
    <ul class="steps">
      <li>égalité <pre class="inline"><code class="javascript">expect(x)/*not.*/.to./*deep.*/equals(y)</code></pre></li>
      <li>existance <pre class="inline"><code class="javascript">expect(x).to.be.null</code></pre> <pre class="inline"><code class="javascript">expect(x).to.exist</code></pre></li>
      <li>taille des tableaux <pre class="inline"><code class="javascript">expect(x).to.be.empty</code></pre> <pre class="inline"><code class="javascript">expect(x).to.have.length(y)</code></pre></li>
      <li>objets <pre class="inline"><code class="javascript">expect(x).to.have./*nested.*/property('model.name').that.equals(z)</code></pre></li>
      <li>contenu <pre class="inline"><code class="javascript">expect(x).to.contain/*.keys*/(y)</code></pre></li>
      <li>nombres <pre class="inline"><code class="javascript">expect(x).to.be.at.least(y).and.at.most(z)</code></pre>
      <li>fourre-tout <pre class="inline"><code class="javascript">expect(1).to.satisfy((num) => {return num > 0;})</code></pre></li>
      <li>exception <pre class="inline"><code class="javascript">expect(() => {}).to.throw(/message/)</code></pre></li>
    </ul>
    <details open>
      <summary/>
      <p>Liste complète disponible sur <a href="http://chaijs.com/api/bdd/" target="_blank">la documentation officielle</a></p>
      <div>Question de syntaxe, vous pouvez préférer <pre class="inline"><code class="javascript">expect(x).to.be.equal(y)</code></pre><div>
      <p>Quelle que soit l'assertion suivante, <strong>not</strong> aura pour effet d'attendre son contraire</p>
      <div>Dans les tests d'égalité, on trouve aussi <pre class="inline"><code class="javascript">expect(x).to.be.true</code></pre></div>
      <p>Si le chemin vers la propriété contient des '.' ou des '[]', il faut utiliser <strong>deep</strong></p>
      <div><pre class="inline"><code class="javascript">expect(x).to.have.property(name, value)</code></pre> permet de tester l'existance et la valeur. On évitera cette forme, car si value est <code>undefined</code>, impossible d'être certains que la propriété existe bel et bien</div>
      <p><strong>contain</strong> et <strong>include</strong> sont strictement synonymes</p>
      <p>Les tests sur les exceptions portent sur l'exécution d'une fonction !</p>
    </details>
  </section>

  <section data-timing="5">
    <h1><i>hooks</i> et exclusions</h1>
    <ul class="steps">
      <li>A l'intérieur d'un <code>describe()</code> : <pre><code class="javascript">describe('Array', () => {
  let array = []

  beforeEach((done) => { // before(), after(), afterEach()
    array = [1, 2, 3];
    done();
  });

  it('should splice() remove elements', {skip: true}, (done) => {
    expect(array.splice(1, 1)).to.deep.equals([1, 3]);
    done();
  })
})</code></pre></li>
      <li>Exécutés quel que soit le résultat des <code>it()</code></li>
      <li><code>only</code> positionne <code>skip</code> sur les autres <code>it</code> du <code>describe()</code></li>
    </ul>
    <details open>
      <summary/>
      <p>Ces "hooks" sont liés au <code>describe()</code> englobant. Ils révèlent le principal intérêt des <code>describe()</code> : grouper les pré-requis et le nettoyage de plusieurs tests</p>
      <p>Il peut y avoir plusieurs fois le même "hook" dans un même <code>describe()</code> : ils seront exécutés dans l'ordre de déclaration</p>
      <p><strong>Attention</strong> : ces "hooks" sont exécutés dans la 2ème phase, en même temps que les <code>it()</code>!</p>
    </details>
  </section>

  <section class="title pause" data-timing="15">
    <div class="bg">
      <img src="images/pause-7.jpg">
    </div>
    <details open>
      <summary>Pause</summary>
    </details>
  </section>

  <section data-timing="40">
    <h1>Tests en actions</h1>
    <ol class="steps hands-on">
      <li>Vous allez tester le module <strong>tp/fs/fs_utils.js</strong>. Dans <strong>tp/fs</strong> utilisez <code>npm init</code> pour générer un descripteur <strong>package.json</strong></li>
      <li>Toujours dans <strong>tp/fs</strong>, installez <strong>mocha</strong> et <strong>chai</strong>: <code>npm
          install --save-dev mocha chai</code></li>
      <li>Dans un module <strong>tp/fs/test/fs_utils.js</strong> réalisez les tests suivants :<ol>
        <li>FS utils getDirContent should return current folder content with absolute paths</li>
        <li>FS utils getDirContent should fail when reading an unknown folder</li>
        <li>FS utils getDirStat should return alphabetically ordered current folder</li>
        <li>FS utils getDirStat should fail when reading an unknown folder</li>
    </ol>
    <details open>
      <summary/>
      <p>Il est plus pratique d'installer <strong>mocha</strong> de manière globale avec <code>npm install -g mocha </code> dans le contexte de cet exercice, sinon on le mettra en devDependencies du projet</p>
    </details>
  </section>

  <!-- Request -->
  <section class="title">
    <div class="bg">
      <img src="images/request.jpg">
    </div>
    <h1>Client Http Request</h1>
  </section>

  <section data-timing="5">
    <h1><a href="https://github.com/request/request" target="_blank">Request </a></h1>
    <ul class="steps">
      <li>Fonctionne le plus simplement possible :<pre><code class="javascript">const request = require('request');
request('http://www.google.com', (err, response, body) => {
  if (!err && response.statusCode === 200) {
    console.log(body);
  }
})</code></pre></li>
      <li>Http ET Https</li>
      <li>Gère les proxy et les redirections</li>
      <li>Permet d'envoyer des formulaires</li>
    </ul>
    <details open>
      <summary/>
      <p>Ce module est l'un des plus anciens (mai 2010) et plus utilisé de la communauté NodeJS, car il palie à la faible utilisabilité du client Http par défaut.</p>
      <p>Le body est soit une chaîne de caractère, soit du JSON, soit un buffer (binaire) en fonction des différentes options passée lors de la requête.</p>
    </details>
  </section>

  <section data-timing="5">
    <h1><a href="https://github.com/request/request#requestoptions-callback" target="_blank">Configuration</a> des requêtes</h1>
    <ul class="steps">
      <li>1er paramètre : une chaîne ou un <i>object literal</i>: <pre><code class="javascript">request({
  url: 'http://www.google.com/search',
  method: 'GET',
  qs: {
    q: 'request'
  },
  proxy: 'http://proxy-internet.localnet:3128'
}, (err, response, body) => {
  // ...
})</code></pre></li>
      <li>Méthode spécifiable avec <code>request.get()</code>, <code>post()</code> etc...</li>
      <li class="warning">Lit les variables d'envir. <strong>HTTP(S)/NO_PROXY</strong></li>
      <li>Permet d'envoyer du json et des formulaires</li>
    </ul>
    <details open>
      <summary/>
      <p>Les options possibles dépendent du verbe utilisé : l'option <code>body</code> n'a pas de sens pour un <strong>GET</strong>.</p>
      <p>L'option <code>json</code> permet d'ajouter les en-têtes <strong>content: application/json</strong> et <strong>accept: application/json</strong>, réalise la sérialisation du corps éventuel de la requête et la désérialisation du corps de la réponse.</p>
      <p>Pour indiquer que la requête ne DOIT PAS utiliser de proxy, malgré la présence de variable d'environnement, il faut spécifier <code>null</code> ou <code>false</code> dans l'option <code>proxy</code>.</p>
      <p>D'une manière générale, il est plus prudent de toujours spécifier l'option proxy, et de mettre vous même la valeur dans un fichier de configuration.</p>
    </details>
  </section>

  <section data-timing="10">
    <h1>Streaming et formulaires</h1>
    <ul class="steps">
      <li><code>request</code>/<code>request.get</code> renvoient un <strong>ReadableStream</strong>: <pre><code class="javascript">request('http://google.com/doodle.png').pipe(fs.createWriteStream('doodle.png'));</code></pre></li>
      <li>Pour <code>request.post</code>/<code>request.put</code>, un <strong>WritableSteam</strong>: <pre><code class="javascript">fs.createReadStream('file.json').pipe(request.put('http://mysite.com/obj.json'));</code></pre></li>
      <li>Envoi d'un formulaire <strong>multipart/urlencoded</strong>: <pre><code class="javascript">request.post('http://service.com/upload').form({key:'value'});</code></pre></li>
      <li>Pour le <strong>multipart/form-data</strong>: <pre><code class="javascript">request.post({url:'http://service.com/upload',
formData: {
  field1: 'my_value',
  field3: fs.createReadStream('unicycle.jpg')
}});</code></pre></li>
    </ul>
    <details open>
      <summary/>
      <p>Dans ces exemples, on ne gère pas les cas d'erreurs.</p>
      <p>Les stream en lecture ont un évènement spécial <strong>response</strong> lorsque les en-têtes de la réponse sont disponibles. L'évènement <strong>error</strong> doit être écouté pour gérer les erreurs de réception.</p>
      <p>Lorsqu'on envoi un formulaire, le bon <strong>content-type</strong> est positionné.</p>
      <p>L'objet <strong>FormData</strong> qui modélise le formulaire est accessible en retour de la méthode <code>request.post(...).form();</code>. Rappelez vous que l'envoi est asynchrone : le formulaire peut être modifié immédiatement après l'appel à <code>post()</code>.</p>
      <p>On peut aussi envoyer un formulaire <strong>multipart/related</strong> avec l'option <code>multipart</code> de <code>request.post()</code>.</p>
    </details>
  </section>

  <section data-timing="10">
    <h1>La librairie <i>request<i></h1>
    <ol class="steps hands-on">
      <li>Créer un nouveau fichier <strong>tps/request/request.js</strong> qui appelle l'API <a href="http://api.icndb.com/jokes/random">http://api.icndb.com/jokes/random</a> et logguer la joke retournée.
        <ol>
          <li class="warning">Attention au proxy</li>
        </ol>
      </li>
      <li>Modifier la requête pour remplacer le prénom de la fact par votre prénom (voir la doc de l'API : <a href="http://www.icndb.com/api/">http://www.icndb.com/api/</a>)
    </ol>
    <details open>
      <summary/>
    </details>
  </section>

  <section class="title pause" data-timing="120">
    <div class="bg">
      <img src="images/pause-8.jpg">
    </div>
    <details open>
      <summary>Pause</summary>
    </details>
  </section>

  <!-- express -->
  <section id="express" class="title">
    <div class="bg">
      <img src="images/express.jpg">
    </div>
    <h1>La librairie <a href="http://expressjs.com">express</a></h1>
  </section>

  <section id="express-intro" data-timing="10">
    <h1><a href="http://expressjs.com">express</a></a></h1>
    <ul>
      <li class="step">Utilisation de http.Server avec les améliorations suivantes :
      <ol>
        <li class="step">Routage des url par chemin et verbe HTTP</li>
        <li class="step">Parsage des paramètres d'entrée</li>
        <li class="step">Gestion des fichiers statiques</li>
        <li class="step">Templating HTML</li>
        <li class="step">Et c'est tout !</li>
      </ol>
      </li>
      <li class="step">Mécanisme de middlewares pour ajouter des fonctionnalités</li>
    </ul>
    <details open>
      <summary/>
      <p>Le <strong>router</strong> permet d'associer un traitement spécifique (une fonction) à une url et un verbe bien particulier.</p>
      <p>La requête d'entrée est parsée (JSON) et éventuellement validée avec un middleware.</p>
      <p>La constitution des réponses (en-têtes, cache HTTP...) est facilitée, et des middlewares existent pour le contenu statique (fichier, dossiers).</p>
      <p>Le mécanisme de templating permet d'utiliser des templates handlebars (par exemple) pour constituer la réponse avec des placeholders.</p>
      <p>Une librairie volontairement simple et réduite en terme de fonctionnalité, mais les middlewares permettent d'ajouter des fonctionnalités (gzip, authent...)</p>
      <p>La structure en middlewares rend son utilisation simple à comprendre et facile à faire évoluer</p>
    </details>
  </section>

  <section data-timing="5">
    <h1>Anatomie du serveur</h1>
    <ul class="steps">
      <li class="no-bullet"><pre><code class="javascript">const express = require('express');
const app = express();

app.get('/:name', (req, res) => {
  res.send('Hello ' + req.params.name);
});

app.listen(3000, () => {
  console.log('Example app listening on port 3000!');
});</code></pre></li>
      <li>Les routes peuvent contenir des paramètres</li>
      <li><code>req</code> étend http.IncomingMessage</li>
      <li><code>res</code> étend http.ServerResponse</li>
    </ul>
    <details open>
      <summary/>
      <p>Les paramètres de chemins peuvent être facultatif (suffixé par <code>?</code>).</p>
      <p><code>req</code> encapsule l'objet <a href="https://nodejs.org/api/http.html#http_http_incomingmessage" target="_blank"><code>IncomingMessage</code></a> de Node, et propose ses propres <a href="http://expressjs.com/en/4x/api.html#req" target="_blank">propriétés</a> comme les paramètres de requêtes extraits (<code>query</code>), le corps de la requête parsé (<code>body</code>)</p>
      <p><code>resp</code> est un objet <a href="http://expressjs.com/en/4x/api.html#res" target="_blank">réponse</a> permettant de modifier les entêtes de réponse (<code>header()</code>, <code>type()</code>, le code HTTP (<code>status()</code>), les cookies (<code>cookie()</code>), les redirections...</p>
    </details>
  </section>


  <section data-timing="5">
    <h1>Les middlewares</h1>
    <ul class="steps">
      <li>Liste de fonctions à exécuter pour chaque requête, dans l'ordre où elles sont définies</li>
      <li>Par exemple:<pre><code class="javascript">(req, res, next) => {
  next();
};</code></pre>
      </li>
      <li>Un middleware peut:
        <ul>
          <li>modifier la requête ou la réponse</li>
          <li>répondre immédiatement au client et stopper le traitement de la requête</li>
          <li>émettre une erreur</li>
        </ul>
      </li>
      <li class="step">Plein de middlewares ! <a href="http://expressjs.com/en/resources/middleware.html">http://expressjs.com/en/resources/middleware.html</a></li>
    </ul>
    <details open>
      <summary/>
      <p><strong>next()</strong> n'est pas obligatoire</p>
      <p>manipuler les variables <strong>req</strong> et <strong>res</strong></p>
      <p>Appeler <strong>res.end()</strong> ou <strong>res.send()</strong> pour mettre fin au traitement</p>
      <p>Appeler <strong>next()</strong> pour passer au middleware suivant, ou <strong>next(err)</strong> pour passer au middleware d'erreur</p>
    </details>
  </section>

  <section data-timing="5">
    <h1>Le middleware d'erreur</h1>
    <ul class="steps">
      <li>appelé en cas d'erreur (appel à <strong>next()</strong> avec une erreur en paramètre)</li>
      <li>par exemple:<pre><code class="javascript">(err,req, res, next) => {
  res.status(500).send('an error occured');
};</code></pre>
      </li>
      <li class="warning">le paramètre <strong>next</strong> est obligatoire (même s'il n'est pas utilisé)</li>
    </ul>
    <details open>
      <summary/>
    </details>
  </section>

  <section data-timing="5">
    <h1>Utilisation d'un middleware</h1>
    <ul class="steps">
      <li>app.use([path,] function [, function...]):<pre><code class="javascript">app.use((req, res, next) => {
  console.log('start request %s %s', req.method, req.originalUrl);
  next();
});</code></pre></li>
      <li>app.get(path, function [, function...]):<pre><code class="javascript">app.get('/hello', (req, res, next) => {
  res.send('Hello world!')
});</code></pre></li>
      <li>existe pour toutes les methodes: post(), put()...</li>
    </ul>
    <details open>
      <summary/>
      <p>Le path est optionnel pour use(), plusieurs middlewares peuvent être passés en paramètre</p>
    </details>
  </section>

  <section data-timing="45">
    <h1>Express !</h1>
    <ol class="hands-on">
      <li class="step">Créez un serveur express dans un module <strong>tps/express/server.js</strong>.</li>
      <li class="step">Ajouter les fonctionnalités suivantes avec les tests associés (dans un fichier tps/express/test/server.js)
        <ol>
          <li class="step">Le serveur démarre et renvoit une 404 sur n'importe quelle url</li>
          <li class="step">Le serveur répond 'Hello XXX' quand on appelle l'URL '/hello/XXX', l'utilisateur pouvant remplacer XXX par le prénom de son choix</li>
          <li class="step">Le serveur répond une erreur 400 si le prénom passé en paramètre fait moins de 3 caractères. La réponse sera en JSON et le message d'erreur sera dans une propriété 'message'</li>
          <li class="step">Logguer toutes les requêtes en utilisant <a href="https://www.npmjs.com/package/morgan">morgan</a> (pas de test à faire)</li>
        </ol>
      </li>
      <li class="step">Bonus: Utiliser un moteur de template pour que l'URL '/hello/XXX' retourne une page au format HTML</li>
    </ol>
    <details open>
      <summary/>
      <p>Pour créez rapidement son fichier <strong>package.json</strong> : <code>> npm init</code>.</p>
      <p>Ajouter rapidement des modules externes : <code>> npm install --save(-dev) moduleA moduleB</code>.</p>
      <p>Le fichier source doit exporter le serveur sans le démarrer : c'est le test qui appelera <code>start()</code> et <code>stop()</code>.</p>
      <p>Pour invoquer une url du serveur depuis les tests, utilisez la librairie request.</p>
      <p>Pensez a tester les codes de retour HTTP, et les entêtes importants. La réponse parsée est disponible depuis le test avec <code>res.body</code>.</p>
      <p>Mettre morgan en premier pour bien logguer toutes les requêtes</p>
    </details>
  </section>

  <section id="async" class="title">
    <div class="bg">
      <img src="images/async.jpg">
    </div>
    <h1>Dodge callback hell with async</h1>
  </section>

  <section data-timing="5">
    <h1>"Pyramid of Doom" ??</h1>
    <pre class="step"><code class="javascript">fs.readdir(source, (err, files) => {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach((filename, fileIndex) => {
      console.log(filename)
      gm(source + filename).size((err, values) => {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach((width, widthIndex) => {
            height = Math.round(width / aspect)
            console.log('resizing '+filename+'to '+height+'x'+height)
            this.resize(width, height).write(destination+'w'+width+'_'+filename,
              (err) => {
                if (err) console.log('Error writing file: ' + err)
              })
          }.bind(this))
        }
      })
    })
  }
})</code></pre>
    </ul>
    <details open>
      <summary/>
      <p>Exemple proposé par <a href="http://callbackhell.com/" target="_blank">callbackhell.com</a></p>
      <p><a href="http://djebbz.github.io/async-paris-js/#/async-map" target="_blank">Présentation</a> de async</p>
    </details>
  </section>

  <section data-timing="10">
    <h1>Asynchronisme et tableaux</h1>
    <ul>
      <li class="step">Appliquer un traitement asynchrone à un tableau<pre><code class="javascript">async.map(['file1','file2','file3'], (file, next) => {
  // appliqué de manière asynchrone sur tous les éléments du tableau
  // la signature de next est next(err, result)
  fs.readFile(file, next);
}, (err, results) => {
  // err est la première erreur renvoyée
  // results est le tableau (ordonné) des résultats intermédiaires
});</code></pre></li>
      <li class="step">Tous les traitements sont déclenchés en parallèle<span class="hints line"><span class="step">mapLimit</span><span class="step">mapSeries</span></span></li>
      <li class="step">Le callback de fin est déclenché... à la fin</li>
      <li class="step">Le premier échec déclenche le callback de fin, et ignore les résultats en cours</li>
    </ul>
    <details open>
      <summary/>
      <p><code>mapLimit(arr, n, ...)</code> lance les N première tâches et attend d'en avoir terminé avant d'en relancer d'autres</p>
      <p><code>mapSeries()</code> lance les tâches les unes à la suite des autres, dans l'ordre. C'est équivalent à <code>mapLimit(arr, 1, ...)</code></p>
      <p>Les autres fonctions : <ul>
        <li><code>each()</code>, <code>eachLimit()</code>, <code>eachSeries()</code> qui invoque une fonction asynchrone sur chaque élément</li>
        <li><code>filter()</code>, <code>filterSeries()</code> qui ne conserve que les élements passant le test asynchrone</li>
        <li><code>reject()</code>, <code>rejectSeries()</code> qui conserve les élements ne passant pas le test asynchrone</li>
        <li><code>reduce()</code>, <code>reduceRight()</code> identique à <strong>Array.reduce()</strong> en mode asynchrone</li>
        <li><code>sortBy()</code> qui extrait de manière asynchrone une valeur servant pour le tri qui intervient dans un 2ème temps</li>
        <li><code>detect()</code>, <code>detectSeries()</code> renvoie le premier élément passant le test asynchrone (attention, non ordonné !)</li>
        <li><code>some()</code> renvoie true si au moins un élément passe le test asynchrone (attention, non ordonné !)</li>
        <li><code>every()</code> renvoie true si tous les éléments passe le test asynchrone</li>
        <li><code>concat()</code>, <code>concatSeries()</code> renvoie la concaténation des résultats de la fonction asynchrone appliquée à chaque élément</li>
      </ul></p>
    </details>
  </section>

  <section data-timing="10">
    <h1>Asynchronisme et functions</h1>
    <ul>
      <li class="step">Gérer un flow de fonctions asynchrones<pre><code class="javascript">async.parallel([
  (done) => {
    // la signature de done est done(err, result)
    fs.readFile('in.txt', done);
  }, (done) => {
    fs.writeFile('out.txt', 'finished !', done);
  }
], (err, results) => {
    // err est la première erreur renvoyée
    // results est le tableau (ordonné) des resultats intermédiaires
});</code></pre></li>
      <li class="step">Tous les traitements sont déclenchés en parallèle<span class="hints line"><span class="step">parallelLimit</span><span class="step">series</span></span></li>
      <li class="step">Le callback de fin est déclenché à la fin, <br/>ou suite au premier échec</li>
    </ul>
    <details open>
      <summary/>
      <p>il est aussi possible de spécifier un objet et pas un tableau : <pre><code class="javascript">async.parallel({
  one: (done) => {
    // la signature de done est done(err, result)
    fs.readFile('in.txt', done);
  }, two: (done) => {
    fs.writeFile('out.txt', 'finished !', done);
  }
], (err, results) => {
    // err est la première erreur renvoyée
    // results reprends les clé de l'objet initial: {one: '', two: ''}
});</code></pre> Attention néanmoins, il n'y a pas d'ordre garanti...</p>
    </details>
  </section>

  <section id="async-functions" data-timing="5">
    <h1>Asynchronisme et functions</h1>
    <ul class="steps">
      <li><code>whilst()</code>, <code>doWhilst()</code>: executer une function asynchrone tant que le test synchrone est vrai</li>
      <li><code>until()</code>, <code>doUntil()</code>: executer une function asynchrone jusqu'a ce que le test synchrone soit vrai</li>
      <li><code>seq()</code>, <code>compose()</code>, <code>waterfall()</code>: passe les résultats de l'étape N à l'étape N+1</li>
      <li><code>queue()</code>, <code>cargo()</code>: pool d'exécution asynchrone<br/><img src="https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966"/></li>
    </ul>
    <details open>
      <summary/>
      <p><code>queue()</code>, <code>priorityQueue()</code> permet d'exécuter des tâches en parallèle jusqu'à une limite de concurrence donnée</p>
      <p>Ces pools d'exécution tournent en tâche de fond jusqu'à ce qu'on les stoppe</p>
      <p>Encore plein d'autres patterns proposés plus ou moins complexes</p>
    </details>
  </section>

  <section data-timing="40">
    <h1>Utiliser <i>async</i></h1>
    <ol class="steps hands-on">
      <li>Maintenant que <strong>tps/fs/fs_utils.js</strong> est testé, nous allons le refactoriser</li>
      <li>Refactorisez l'implémentation de <code>getDirStat</code> en utilisant <strong>async</strong></li>
      <li>TODO test avec des fonctions, 20 minutes</li>
    </ol>
    <details open>
      <summary/>
    </details>
  </section>

  <section class="title pause" data-timing="15">
    <div class="bg">
      <img src="images/pause-9.jpg">
    </div>
    <details open>
      <summary>Pause</summary>
    </details>
  </section>

  <section id="promises" class="title">
    <div class="bg">
      <img src="https://media.giphy.com/media/l1J9wZJLPywQuKovK/giphy.gif">
    </div>
    <h1>Les promesses</h1>
  </section>

  <section data-timing="5">
    <h1>Une promesse ?</h1>
    <ul>
      <li>Classe présente dans Javascript (ES6, NodeJS >= 6.5.0)</li>

      <li>Le constructeur :
        <code>
            new Promise((resolve, reject) => { ... });
        </code>
        <ul>
          <li><code>resolve()</code> doit être appelé en cas de succès (accepte en paramètre le résultat du traitement)</li>
          <li><code>reject()</code> doit être appelé en cas d'erreur (accepte en paramètre l'erreur)</li>
        </ul>
      </li>

      <li>Le prototype contient les méthodes :
        <ul>
          <li><code>then()</code> définit une fonction appelée lors que la promesse est résolue</li>
          <li><code>catch()</code> définit une fonction appelée lors que la promesse est rejetée</li>
        </ul>
      </li>
    </ul>
    <details open>
      <summary/>
    </details>
  </section>

  <section data-timing="5">
    <h1>Une promesse ? L'exemple</h1>
    <ul>
      <li>Création de la promesse<pre><code class="javascript">const request = require('request');
const getHello = () => {
return new Promise((resolve, reject) => {
  request('http://google.com/', (err, res) {
    if(err) {
      reject(err);
      return;
    }
    resolve(res);
  });
});</code></pre></li>
    </ul>
    <details open>
      <summary/>
    </details>
  </section>

  <section data-timing="5">
      <h1>Une promesse ? L'exemple</h1>
      <ul>
        <li>Utilisation de la promesse<pre><code class="javascript">getHello().then((res) => {
  console.log(res.statusCode);
})
.catch((err) => {
  console.log(err);
})
</code></pre></li>
      </ul>
      <details open>
        <summary/>
      </details>
    </section>

    <section data-timing="5">
      <h1>Les états de la promesse</h1>
      <div>
        <img src="images/promises.svg">
      </div>
      <ul>
        <li>source : <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a></li>
      </ul>
      <details open>
        <summary/>
      </details>
    </section>

    <section data-timing="5">
      <h1>Le chaînage</h1>
      <ul>
        <li>Exécution en série<pre><code class="javascript">doSomething().then(function(result) {
  // doSomethingElse retourne une promesse
  return doSomethingElse(result);
})
.then(function(newResult) {
  // doThirdThing retourne une promesse
  return doThirdThing(newResult);
})
.then(function(finalResult) {
  console.log('Got the final result: ' + finalResult);
})
.catch(failureCallback);
          </code></pre></li>
          <li>Chaînage possible si la fonction dans <code>then()</code> retourne une promesse</li>
          <li>Equivalent pour les promesses de <code>async.series()</code></li>
          <li>
            source : <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a>
          </li>
        </ul>
      <details open>
        <summary/>
      </details>
    </section>

    <section data-timing="5">
      <h1>Promesses : autres outils</h1>
      <ul>
        <li><code>Promise.all</code>
          <ul>
            <li>Accepte en paramètre un tableau de promesses</li>
            <li>Permet d'exécuter plusieurs promesses en parallèle</li>
            <li>Retourne une promesse, rejetée à la première erreur, ou résolue quand toutes les promesses en entrée sont résolues</li>
            <li>Equivalent pour les promesses de <code>async.parallel()</code></li>
          </ul>
        </li>
        <li>A partir de NodeJS 8 : <code>util.promisify()</code> et <code>util.callbackify()</code> pour convertir des fonctions "callback-style" en fonction "promise-style" et inversement</li>
      </ul>
      <details open>
        <summary/>
        <p><code>util.promisify()</code> nécessite que le callback soit le dernier paramètre de la fonction</p>
      </details>
    </section>

    <section id="async-await" class="title">
      <div class="bg">
        <img src="https://media.giphy.com/media/UO95NWY0PmoWk/giphy.gif">
      </div>
      <h1>Async / Await</h1>
    </section>

    <section data-timing="5">
      <h1>async</h1>
      <ul>
        <li>A partir de NodeJS 8</li>
        <li><code>async</code> est un nouveau mot-clé à placer devant une déclaration de fonction</li>
        <li>La fonction va alors retourner une promesse qui sera
          <ul>
            <li>rejetée si une erreur survient</li>
            <li>résolue avec le résultat retourné par la fonction</li>
          </ul>
        </li>
        <li>Exemple: <pre><code class="javascript">const doHello = async (name) => {
  if(! name) {
    throw 'name is missing';
  }
  return `Hello ${name}`
};</code></pre></li>
      </ul>
      <details open>
        <summary/>
      </details>
    </section>

    <section data-timing="5">
      <h1>await</h1>
      <ul>
        <li><code>await</code> est un nouveau mot-clé à placer devant une promesse
          <ul>
            <li>si elle est résolue, son résultat est retourné</li>
            <li>si elle est réjetée, une erreur survient (équivalent du <code>throw</code>)</li>
          </ul>
        </li>
        <li><code>await</code> ne peut être utilisé que dans une fonction <code>async</code></li>
        <li>Exemple: <pre><code class="javascript">const doHelloTwice = async () => {
  const hello1 = await doHello('bob');
  const hello2 = await doHello('alice');
  return `${hello1}, ${hello2}`;
};</code></pre></li>
      </ul>
      <details open>
        <summary/>
      </details>
    </section>

    <section data-timing="5">
      <h1>async/await : les avantages</h1>
      <ul>
        <li>Meilleure gestion des erreurs
          <ul><li>Les erreurs synchrones et asynchrones sont gérées de la même façon</li></ul>
        </li>
        <li>Code simplifié et plus lisible</li>
      </ul>
      <details open>
        <summary/>
      </details>
    </section>

    <section data-timing="40">
      <h1>Utiliser <i>async/await</i></h1>
      <ol class="steps hands-on">
        <li>Maintenant que <strong>tps/fs/fs_utils.js</strong> est testé, nous allons le refactoriser</li>
        <li>Refactorisez l'implémentation de <code>getDirContent</code> en utilisant <strong>async/await</strong></li>
        <li>Mettre à jour les tests :
          <ol>
            <li>pour le test de succès : voir la <a href="https://mochajs.org/#using-async--await">documentation de mocha</a></li>
            <li>pour le test d'erreur, utiliser le plugin <a href="http://chaijs.com/plugins/chai-as-promised/">chai-as-promised</a></li>
          </ol>
        </li>
        <li>Bonus : refactorisez l'implémentation de <code>getDirStat</code> en utilisant <strong>async/await</strong></li>
      </ol>
      <details open>
        <summary/>
      </details>
    </section>

  <section id="sumup" data-timing="10">
    <h1>Récap du troisième jour</h1>
    <ul class="steps">
      <li class="no-bullet"><i class="fa fa-fw fa-archive"></i>Node Package Manager</li>
      <li class="no-bullet"><i class="fa fa-fw fa-recycle"></i>TDD avec Mocha et Chai</li>
      <li class="no-bullet"><i class="fa fa-fw fa-fighter-jet"></i>Client évolué avec Request</li>
      <li class="no-bullet"><i class="fa fa-fw fa-space-shuttle"></i>Serveur évolué avec Express</li>
      <li class="no-bullet"><i class="fa fa-fw fa-phone"></i>Algorithmie asynchrone avec Async</li>
    </ul>
  </section>

  <section id="end" class="title">
    <img src="images/day3-end.jpg">
    <h1>And now, let's ROCK'N ROLL !</h1>
  </section>

  <!-- Credits -->

  <section>
    <h1>Crédits photos</h1>
    <ul>
      <li>Slide 1 - Ricardo Fujii/Grudaemmim</li>
      <li>Slide 2 - Npm inc.</li>
      <li>Slide 9 - Bark</li>
      <li>Slide 17 - Antonio Santa-Pau Ramírez</li>
      <li>Slide 23 - <a href="https://www.flickr.com/photos/30474136@N07/21866574824/">https://www.flickr.com/photos/30474136@N07/21866574824/</a></li>
      <li>Slide 30 - Inception</li>
      <li>Slide 38 - Ricardo Fujii/Grudaemmim</li>
    </ul>
  </section>

  <script src="components/jquery/jquery.min.js"></script>
  <script src="components/keymaster/keymaster.js"></script>
  <script src="components/hammerjs/hammer.min.js"></script>
  <script src="components/highlightjs/highlight.pack.js"></script>
  <script src="components/ruban/js/ruban.min.js"></script>
  <script src="js/rock-the-web.js"></script>
  <script>
    var ruban = new Ruban({
      pagination: true,
      ratio: 4/3,
      bindMouseWheel: true,
      fontRatio: 0.28
    });
  </script>
</body>
</html>
